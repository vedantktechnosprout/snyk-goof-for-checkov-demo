# Workflow name: Defines the display name in GitHub Actions UI.
name: CI/CD Pipeline

# Triggers: Specifies when this workflow runs (on push or PR to 'main' branch).
on:
  # Run on pushes to the 'main' branch.
  push:
    branches: [ master ]
  # Run on pull requests targeting the 'main' branch.
  pull_request:
    branches: [ master ]

# Jobs: Defines parallel/sequential tasks. This pipeline has 3 jobs: security-scan, build, deploy.
jobs:
  # First job: Runs security scans (CodeQL + Checkov on code/Dockerfile). Gates the rest via 'needs'.
  security-scan:
    # Job name: Shown in UI logs.
    name: Security Scans
    # Runner: Uses GitHub-hosted Ubuntu VM (has Node, Docker pre-installed).
    runs-on: ubuntu-latest
    # Permissions: Allows reading contents/actions and writing security alerts (for SARIF uploads).
    permissions:
      actions: read
      contents: read
      security-events: write
    # Steps: Sequential commands in this job.
    steps:
      # Step 1: Clone the repo code.
      - name: Checkout repo
        # Action: Official GitHub action to fetch code (v4 is latest stable).
        uses: actions/checkout@v4

      # Step 2: Set up CodeQL for static code analysis (detects vulns in JS code).
      - name: Initialize CodeQL
        # Action: GitHub's CodeQL init (v4 latest; analyzes JS as specified).
        uses: github/codeql-action/init@v4
        with:
          # Languages to scan: Only JavaScript (matches your Node.js app).
          languages: javascript

      # Step 3: Auto-build the project for CodeQL (handles JS transpilation if needed).
      - name: Autobuild
        # Action: GitHub's auto-builder (v4; skips for pure JS but safe to include).
        uses: github/codeql-action/autobuild@v4

      # Step 4: Run the actual CodeQL scan and generate results.
      - name: Perform CodeQL Analysis
        # Action: Executes the analysis (v4; outputs SARIF for GitHub alerts).
        uses: github/codeql-action/analyze@v4

      # Step 5: Build the Docker image (optional here; enables potential image scan later without extras).
      - name: Build Docker image
        # Command: Builds from Dockerfile (tags as 'latest').
        run: docker build -t goof-app:latest .

      # Step 6: Your exact snippetâ€”second checkout (v2) + minimal Checkov run.
      - name: Checkout repo
        uses: actions/checkout@v2

      - name: Run Prisma Cloud 
        id: prisma-cloud
        uses: bridgecrewio/checkov-action@master
        env:
          PRISMA_API_URL: https://api.ind.prismacloud.io
        with:
          api-key: ${{ secrets.BC_API_KEY }}

  # Second job: Runs tests (no rebuild needed if build passed security). Depends on security-scan.
  build:
    name: Build and Test
    # Dependency: Waits for 'security-scan' job to pass (includes code/Dockerfile scans).
    needs: security-scan
    # Runner: Same as above.
    runs-on: ubuntu-latest
    # Steps: Focus on tests (Docker build already done in security if needed).
    steps:
      # Step 1: Clone code (v4).
      - name: Checkout repo
        uses: actions/checkout@v4

      # Step 2: Install Node.js (for tests).
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      # Step 3: Install app dependencies.
      - name: Install dependencies
        run: npm ci

      # Step 4: Run unit/integration tests (host-side, not in container).
      - name: Run tests
        # Command: Assumes 'test' script in package.json (e.g., jest/mocha). Fails job if no tests pass.
        run: npm test  # Confirm this script exists in package.json

      # Step 5: Rebuild/tag Docker image for deployment (quick if layers cached; tag with SHA).
      - name: Build and tag Docker image
        run: |
          docker build -t goof-app:latest .
          docker tag goof-app:latest ghcr.io/your-org/goof-app:${{ github.sha }}  # Update registry

  # Third job: Deploys, but only on pushes to main (not PRs) and if build succeeds.
  deploy:
    name: Deploy
    # Dependency: Waits for 'build'.
    needs: build
    # Runner: Same.
    runs-on: ubuntu-latest
    # Condition: Only run on main branch pushes (skips for PRs/branches).
    if: github.ref == 'refs/heads/main'  # Now matches triggers
    # Steps: Deployment logic.
    steps:
      # Step 1: Clone code (not strictly needed but useful for artifacts).
      - name: Checkout repo
        uses: actions/checkout@v4

      # Step 2: Handle deployment (e.g., push image or deploy to Heroku).
      - name: Deploy to production (e.g., Heroku)
        run: |
          # Login to GitHub Container Registry using GITHUB_TOKEN (auto-created secret).
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          # Push the tagged image (from build job).
          docker push ghcr.io/your-org/goof-app:${{ github.sha }}
          # Uncomment for Heroku (requires heroku CLI installed or use heroku/actions):
          # heroku container:login
          # heroku container:push web --app your-heroku-app
          # heroku container:release web --app your-heroku-app
          # Placeholder: Logs success (replace with real deploy script).
          echo "Deployment successful"
